---
typora-copy-images-to: imgs
---

#### 2.1 python中一切皆对象

​	python中类和函数也都是对象

![1535802745613](F:\python_jinjie\imgs\1535802745613.png)



#### 2.2 `type`  `object` 和 `class` 的关系

​	![1535803793178](F:\python_jinjie\imgs\1535803793178.png)

​	object是type的实例,       `str` `list` `dict`等都是type的实例,同时type也继承了object(有点绕),type也是type自身的一个实例,一切皆对象,一切皆继承自object.  type自己也是自己的对象实例

#### 2.3 python中的常见内置类型

​	![1535804480108](F:\python_jinjie\imgs\1535804480108.png)

​	a = None 

​	b = None 则 id(a) ==id(b)为true

python代码本身也会被python解释器变成对象类型

type也是一种类型

### 第三章 魔法函数

#### 3.1 什么是魔法函数

双下划线开头,双下划线结尾

使用python提供的魔法函数,不能自己去定义魔法函数

魔法函数会贯穿整个课程

#### 3.2 python的数据模型以及数据模型对python的影响

魔法函数是独立于类和object外的,直接会影响到某一个类使用python的语法

python的默认语法会在执行语句时默认的去调用魔法函数,如果修改魔法函数的话,也就影响了Python的语法

**魔法函数定义后不需要显式的去调用**

#### 3.3 魔法函数一览

非数学运算和数学运算,分散在后续章节中介绍

#### 3.4  len函数的特殊性

`len`函数会隐式的去调用`__len__`函数

使用python时尽量使用python内置的数据类型

### 第四章 深入类和对象

#### 4.1 鸭子类型和多态

当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子,那么这只鸟就可以被称为鸭子

extend方法只需传入可迭代类型 iterable

如果一个对象实现了`__getitem__`方法，那python的解释器就会把它当做一个`collection`，就可以在这个对象上使用切片，获取子项等方法；

如果一个对象实现了`__iter__`和`next`方法，python就会认为它是一个`iterator`，就可以在这个对象上通过循环来获取各个子项。 

#### 4.2 抽象基类(abc模块)

python中的抽象基类不能实例化,动态语言是没有变量类型的,变量只是一个符号,可以赋值任意类型

python中少了编译时查错的功能

类似于Java中的接口,我们需要强制某个子类必须实现某些方法,需要设计一个抽象基类， 指定子类必须实现某些方法

#### 4.3 使用isinstance而不是type

isinstance会循着继承链去寻找

#### 4.4 类变量和对象变量(实例变量)

![1535875262123](F:\python_jinjie\imgs\1535875262123.png)

#### 4.5 类属性和实例属性以及查找顺序

由下而上的查找顺序

深度优先算法

![1535875921294](F:\python_jinjie\imgs\1535875921294.png)

广度优先算法

![1535876056832](F:\python_jinjie\imgs\1535876056832.png)

python 3中采用 C 3 算法

#### 4.6 类方法 静态方法 实例方法的区别

![1535876819819](F:\python_jinjie\imgs\1535876819819.png)

![1535877003172](F:\python_jinjie\imgs\1535877003172.png)

#### 4.8 数据封装和私有属性

![1535877568645](F:\python_jinjie\imgs\1535877568645.png)

#### 4.9 python的自省机制

自省是通过一定的机制查询到对象的内部结构

#### 4.10 super函数

super(). `__init__` 不是调用父类构造函数的意思,而是调用`mro`中的下一个函数

super的调用顺序和 `mro` 中的顺序保持一致

#### 4.11 mixin继承案例

混合模式

特点:

Mixin类功能单一

不和基类关联,可以和任意基类组合

在Mixin中不要使用super这种用法

#### 4.12 python中的with语句(上下文管理器)

try except finally

with语法可以优化上述语句

![1535891018615](F:\python_jinjie\imgs\1535891018615.png)

`contextlib` 简化上下文管理器

### 第五章 自定义序列类

#### 5.1 序列类型的分类

![1535940230945](F:\python_jinjie\imgs\1535940230945.png)

#### 5.2 序列类型的abc继承关系

#### 5.3 list中+ , += , extend方法的区别

extend方法没有返回值,直接在原值上修改

extend传入可迭代对象,对其迭代一个一个加在原值后

append传入可迭代对象,直接将其作为一个值,加在原值后

#### 5.4 实现可切片的对象

切片操作返回一个新值,不会改变原先的值

![1535941719710](F:\python_jinjie\imgs\1535941719710.png)

实现不可变序列Sequence中的魔法函数,也就实现了一个可切片的对象,其中getitem是关键

#### 5.5 bisect 维护已排序序列

用来处理已排序的序列，用来维持已排序的序列,升序

#### 5.6 什么时候我们不该使用列表

array和list的一个重要区别， array只能存放指定的数据类型,但是array的效率高于list

#### 5.7 列表推导式 生成器表达式 字典推导式

列表推导式: 通过一行代码来生成列表

![1535944889788](F:\python_jinjie\imgs\1535944889788.png)

生成器表达式: ![1535944965229](F:\python_jinjie\imgs\1535944965229.png)

会在后续章节中介绍

字典推导式:

![1535945190160](F:\python_jinjie\imgs\1535945190160.png)



### 第六章 深入python的set和dict

#### 6.2 dict的常用方法

深拷贝和浅拷贝

#### 6.3 dict的子类

defaultdict

#### 6.4 set和frozenset

frozenset 不可变集合 是不可变类型,可以作为dict的key

set 无序,不重复集合

set的性能很高

集合的差,交,并操作

#### 6.5 dict和set的实现原理

dict查找的性能远远大于list

在list中随着list数据的增大 查找时间会增大

在dict中查找元素的时间不会随着dict的增加而增加

![1535961216258](F:\python_jinjie\imgs\1535961216258.png)

1.  dict的key或者set的值 都必须是可以hash的
  不可变对象 都是可hash的， str， frozenset， tuple，自己实现的类 `__hash__`
2.  dict的内存花销大，但是查询速度快， 自定义的对象 或者python内部的对象都是用dict包装的
3.  dict的存储顺序和元素添加顺序有关
4.  添加数据有可能改变已有数据的顺序 

### 第七章 对象引用 可变性和垃圾回收

#### 7.1 python中的变量是什么

python和java中的变量本质不一样，python的变量实质上是一个指针 int str， 便利贴

#### 7.2 ==和is的区别

is 判断的是两个变量的id

== 判断值是否相等

![1535975032792](F:\python_jinjie\imgs\1535975032792.png)

#### 7.3 del语句和垃圾回收

cpython中垃圾回收的算法是采用 **引用计数**

![1535975288779](F:\python_jinjie\imgs\1535975288779.png)

#### 7.4 一个经典的参数错误



![1535975644476](F:\python_jinjie\imgs\1535975644476.png)

![1535975627520](F:\python_jinjie\imgs\1535975627520.png)

com2 和 com3共用了同一个默认的staff list

### 第八章 元类编程

#### 8.1 property动态属性

#### 8.2 `__getattr__` `__getattribute` 的区别

```
__getattr__ 就是在查找不到属性的时候调用
```

```
__getattribute__ 在查找任何属性时都会调用
```

#### 8.3 属性描述符和属性查找过程

属性描述符: 实现`__set__` `__get__` `__delete` 中的任意一个魔法函数

![1535978163640](F:\python_jinjie\imgs\1535978163640.png)

#### 8.4 `__new__` 和 `__init__`  方法的区别

```
#new 是用来控制对象的生成过程， 在对象生成之前
#init是用来完善对象的
#如果new方法不返回对象， 则不会调用init函数
```

#### 8.5 自定义元类

type创建动态类

```
什么是元类， 元类是创建类的类 对象 <--class(对象) <--type
type就是元类
```

#### 8.6 通过元类实现ORM

### 第九章 迭代器和生成器

9.1 python中的迭代协议

```
什么是迭代协议
#迭代器是什么？ 迭代器是访问集合内元素的一种方式， 一般用来遍历数据
#迭代器和以下标的访问方式不一样， 迭代器是不能返回的, 迭代器提供了一种惰性方式数据的方式
```

可迭代类型和迭代器的区别:

实现`__iter__`  魔法函数即为可迭代类型

迭代器还必须实现`__next__` 魔法函数 后面将进一步介绍

#### 9.2 什么是迭代器和可迭代对象

![1536066011430](F:\python_jinjie\imgs\1536066011430.png)

#### 9.3 生成器函数的使用

**生成器函数，函数里只要有yield关键字**

函数返回一个生成器对象,不是值.该对象在python编译字节码的时候就产生了

为惰性求值， 延迟求值提供了可能

#### 9.4 python是如何实现生成器的

```
python.exe会用一个叫做 PyEval_EvalFramEx(c函数)去执行foo函数， 首先会创建一个栈帧(stack frame)
```

可以在任何地方,任何函数,任何模块中,只要拿到生成器对象,都可以去恢复它,都可以去暂停它,正是因为任何地方都可以控制,才有了协程的原理

#### 9.5 生成器在UserList中的应用

#### 9.6 生成器如何读取大文件 

![1536068835999](F:\python_jinjie\imgs\1536068835999.png)

### 第十章 python socket编程

![1536069277288](F:\python_jinjie\imgs\1536069277288.png)

client和server实现通信

![1536069790351](F:\python_jinjie\imgs\1536069790351.png)